<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diya-Motors Self-Attendance</title>
    <!-- Font Awesome for icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Global box-sizing for consistent layout */
        * {
            box-sizing: border-box;
        }

        /* Prevent layout shifts by always showing scrollbar */
        html {
            overflow-y: scroll;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: #333;
            padding: 16px;
        }

        /* Base card/container styles */
        .card {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 24px;
            width: 100%;
            max-width: 480px;
            animation: fadeIn 0.5s ease-out;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Wider app screen container */
        .app-screen-card {
            max-width: 800px;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Form group styling */
        .form-group {
            margin-bottom: 16px;
        }

        .form-group:last-child {
            margin-bottom: 0;
        }

        /* Input field styling */
        input[type="email"],
        input[type="password"],
        input[type="text"],
        input[type="number"],
        input[type="tel"],
        select {
            /* Added select to input styling */
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            line-height: 1.5;
            color: #4a5568;
            transition: all 0.2s ease-in-out;
        }

        input[type="email"]:focus,
        input[type="password"]:focus,
        input[type="text"]:focus,
        input[type="number"]:focus,
        input[type="tel"]:focus,
        select:focus {
            /* Added select to focus styling */
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
        }

        /* Base button styles */
        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 14px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Specific button colors */
        .btn-primary {
            background-color: #2563eb;
            color: #ffffff;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: #1d4ed8;
        }

        .btn-secondary {
            background-color: #10b981;
            color: #ffffff;
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: #047857;
        }

        .btn-neutral {
            background-color: #6b7280;
            color: #ffffff;
        }

        .btn-neutral:hover:not(:disabled) {
            background-color: #4b5563;
        }

        .btn-danger {
            background-color: #ef4444;
            color: #ffffff;
        }

        .btn-danger:hover:not(:disabled) {
            background-color: #dc2626;
        }

        /* Message box styling */
        .message-box {
            padding: 12px;
            border-radius: 8px;
            font-weight: 500;
            text-align: center;
            margin-top: 16px;
        }

        .message-box.error {
            background-color: #fee2e2;
            color: #b91c1c;
            border: 1px solid #fca5a5;
        }

        .message-box.success {
            background-color: #d1fae5;
            color: #065f46;
            border: 1px solid #a7f3d0;
        }

        /* Modal styling */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: #ffffff;
            padding: 32px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 400px;
            text-align: center;
            transform: translateY(-20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .modal-overlay.show .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .modal-close-btn {
            background: none;
            border: none;
            font-size: 28px;
            font-weight: bold;
            color: #9ca3af;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .modal-close-btn:hover {
            color: #4b5563;
        }

        .modal-body {
            margin-bottom: 24px;
        }

        .modal-footer {
            text-align: right;
        }

        /* App screen specific styles */
        .app-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding-bottom: 16px;
            margin-bottom: 16px;
            border-bottom: 1px solid #e2e8f0;
            gap: 12px;
        }

        @media (min-width: 640px) {
            .app-header {
                flex-direction: row;
                gap: 0;
            }
        }

        .user-info-display {
            font-weight: 600;
            color: #4a5568;
            text-align: center;
        }

        @media (min-width: 640px) {
            .user-info-display {
                text-align: left;
            }
        }

        .location-status-box {
            background-color: #eff6ff;
            border: 1px solid #bfdbfe;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
            text-align: center;
            font-size: 1.125rem;
            font-weight: 600;
            color: #1e40af;
        }

        .location-status-box.verified {
            background-color: #d1fae5;
            border-color: #a7f3d0;
            color: #065f46;
        }

        .location-status-box.error {
            background-color: #fee2e2;
            border-color: #fca5a5;
            color: #b91c1c;
        }

        /* Checkbox and Radio button styling */
        input[type="checkbox"],
        input[type="radio"] {
            margin-right: 8px;
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #cbd5e0;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            position: relative;
            top: 2px;
        }

        input[type="checkbox"]:checked,
        input[type="radio"]:checked {
            background-color: #2563eb;
            border-color: #2563eb;
        }

        input[type="checkbox"]:focus,
        input[type="radio"]:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
        }

        input[type="checkbox"]:checked::before {
            content: '\2713';
            display: block;
            color: white;
            font-size: 14px;
            line-height: 1;
            text-align: center;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        input[type="radio"] {
            border-radius: 50%;
        }

        input[type="radio"]:checked::before {
            content: '';
            display: block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        input[type="checkbox"]:disabled,
        input[type="radio"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #e2e8f0;
        }

        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 12px;
        }

        @media (min-width: 640px) {
            .radio-group {
                flex-direction: row;
                gap: 24px;
            }
        }

        .attendance-buttons {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-top: 32px;
        }

        @media (min-width: 640px) {
            .attendance-buttons {
                flex-direction: row;
                justify-content: space-between;
            }

            .attendance-buttons .btn {
                width: auto;
                flex-grow: 1;
            }

            .attendance-buttons .btn:first-child {
                margin-right: 16px;
            }
        }
    </style>
</head>

<body>
    <!-- Main Application Wrapper -->
    <div id="app-wrapper" class="w-full flex justify-center items-center">

        <!-- Authentication Screens (Login, Phone Verify, OTP, Signup) -->
        <div id="auth-screens" class="card">
            <h1 class="text-2xl sm:text-3xl font-bold text-blue-800 text-center mb-4">Diya-Motors Self-Attendance</h1>

            <!-- Login Form -->
            <div id="login-form" class="space-y-5">
                <div class="form-group">
                    <label for="login-email" class="block text-gray-700 text-sm font-semibold mb-2">Email</label>
                    <input type="email" id="login-email" placeholder="Enter your email">
                </div>
                <div class="form-group">
                    <label for="login-password" class="block text-gray-700 text-sm font-semibold mb-2">Password</label>
                    <input type="password" id="login-password" placeholder="Enter your password">
                </div>
                <button id="login-btn" class="btn btn-primary">
                    <i class="fas fa-sign-in-alt"></i> Login
                </button>
                <div id="login-message" class="message-box hidden"></div>
                <button id="show-signup-btn" class="btn btn-secondary mt-4">
                    New Employee? Sign Up
                </button>
            </div>

            <!-- Phone Verification Form -->
            <div id="phone-verify-form" class="space-y-5 hidden">
                <p class="text-lg text-gray-700 text-center">Please enter the last 4 digits of your registered phone
                    number.</p>
                <div class="form-group">
                    <label for="last-4-digits" class="block text-gray-700 text-sm font-semibold mb-2">Last 4
                        Digits</label>
                    <input type="number" id="last-4-digits" placeholder="e.g., 1234" maxlength="4"
                        oninput="this.value=this.value.slice(0,4)">
                </div>
                <button id="verify-phone-btn" class="btn btn-primary">
                    Verify Phone
                </button>
                <div id="phone-verify-message" class="message-box hidden"></div>
                <button id="back-to-login-btn" class="btn btn-neutral mt-4">
                    Back to Login
                </button>
            </div>

            <!-- OTP Verification Form -->
            <div id="otp-form" class="space-y-5 hidden">
                <p class="text-lg text-gray-700 text-center">An OTP has been sent to your registered phone number.</p>
                <div class="form-group">
                    <label for="otp-input" class="block text-gray-700 text-sm font-semibold mb-2">Enter OTP</label>
                    <input type="number" id="otp-input" placeholder="Enter 6-digit OTP" maxlength="6"
                        oninput="this.value=this.value.slice(0,6)">
                </div>
                <button id="verify-otp-btn" class="btn btn-primary">
                    Verify OTP
                </button>
                <div id="otp-message" class="message-box hidden"></div>
                <button id="resend-otp-btn" class="btn btn-secondary mt-4" disabled>
                    Resend OTP <span id="countdown-timer" class="ml-2"></span>
                </button>
                <div id="recaptcha-container" class="mt-4"></div>
            </div>

            <!-- Signup Form -->
            <div id="signup-form" class="space-y-5 hidden">
                <div class="form-group">
                    <label for="signup-name" class="block text-gray-700 text-sm font-semibold mb-2">Name</label>
                    <input type="text" id="signup-name" placeholder="Enter your full name">
                </div>
                <div class="form-group">
                    <label for="signup-email" class="block text-gray-700 text-sm font-semibold mb-2">Email</label>
                    <input type="email" id="signup-email" placeholder="Enter your email">
                </div>
                <div class="form-group">
                    <label for="signup-password" class="block text-gray-700 text-sm font-semibold mb-2">Password</label>
                    <input type="password" id="signup-password" placeholder="Create a password">
                </div>
                <div class="form-group">
                    <label for="signup-employee-id" class="block text-gray-700 text-sm font-semibold mb-2">Employee
                        ID</label>
                    <input type="text" id="signup-employee-id" placeholder="Enter your employee ID">
                </div>
                <div class="form-group">
                    <label for="signup-phone" class="block text-gray-700 text-sm font-semibold mb-2">Phone Number (e.g.,
                        +919876543210)</label>
                    <input type="tel" id="signup-phone" placeholder="Enter your phone number with country code">
                </div>
               

                <button id="signup-btn" class="btn btn-primary">
                    <i class="fas fa-user-plus"></i> Sign Up
                </button>
                <div id="signup-message" class="message-box hidden"></div>
                <button id="show-login-btn" class="btn btn-neutral mt-4">
                    Already have an account? Login
                </button>
            </div>
        </div>

        <!-- Main App Screen -->
        <div id="app-screen" class="card app-screen-card hidden">
            <div class="app-header">
                <h2 class="text-xl sm:text-2xl font-bold text-blue-800">Diya-Hero Self-Attendance</h2>
                <div class="flex items-center gap-4">
                    <span id="user-display-name" class="user-info-display"></span>
                    <button id="logout-btn" class="btn btn-danger py-2 px-4 w-auto">
                        <i class="fas fa-sign-out-alt"></i> Logout
                    </button>
                </div>
            </div>
            <div id="location-status" class="location-status-box">
                <p><span id="location-message">Checking location...</span></p>
            </div>
            <!-- Location Refresh Button - Always visible on app screen -->
            <div class="flex justify-center mt-4">
                <button id="refresh-location-btn" class="btn btn-secondary w-auto px-6 py-3">
                    <i class="fas fa-sync-alt"></i> Refresh Location
                </button>
            </div>
            <div id="attendance-section" class="space-y-6">
                <div class="form-group">
                    <label for="morning-check"
                        class="flex items-center text-lg font-semibold text-gray-700 cursor-pointer">
                        <input type="checkbox" id="morning-check"> Morning Attendance
                    </label>
                </div>
                <div class="form-group">
                    <label class="block text-lg font-semibold text-gray-700 mb-3">Afternoon Status:</label>
                    <div class="radio-group">
                        <label for="an-enters" class="flex items-center text-base text-gray-700 cursor-pointer">
                            <input type="radio" id="an-enters" name="afternoon-status" value="Enters"> Enters
                        </label>
                        <label for="an-leaves" class="flex items-center text-base text-gray-700 cursor-pointer">
                            <input type="radio" id="an-leaves" name="afternoon-status" value="Leaves"> Leaves
                        </label>
                        <label for="an-none" class="flex items-center text-base text-gray-700 cursor-pointer">
                            <input type="radio" id="an-none" name="afternoon-status" value="None" checked> None
                        </label>
                    </div>
                </div>
                <!-- NEW: Exit Checkbox -->
                <div class="form-group" id="exit-checkbox-group">
                    <label for="exit-checkbox"
                        class="flex items-center text-lg font-semibold text-gray-700 cursor-pointer">
                        <input type="checkbox" id="exit-checkbox"> Mark Exit
                    </label>
                </div>
                <div class="attendance-buttons">
                    <button id="submit-attendance-btn" class="btn btn-primary" disabled>
                        <i class="fas fa-check-circle"></i> Submit Attendance
                    </button>
                </div>
                <div id="attendance-message" class="message-box hidden"></div>
            </div>
        </div>
    </div>

    <!-- Modal for messages -->
    <div id="message-modal-overlay" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title" class="text-xl sm:text-2xl font-bold text-blue-800"></h2>
                <button class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <p id="modal-message" class="text-base sm:text-lg text-gray-700 leading-relaxed"></p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary py-2 px-5 w-auto">OK</button>
            </div>
        </div>
    </div>
    <script>
        // Define the global onloadCallback function for reCAPTCHA
        window.onloadCallback = function () {
            console.log('reCAPTCHA script loaded successfully.');
            // This function can be used to explicitly render a reCAPTCHA widget if needed,
            // but for 'invisible' reCAPTCHA, it's often handled by RecaptchaVerifier directly.
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>

    <script type="module">
        // Firebase Modular SDK v10+ imports
        import {
            initializeApp
        } from 'https://www.gstatic.com/firebasejs/10.0.0/firebase-app.js';
        import {
            getAuth,
            signInWithEmailAndPassword,
            signOut,
            onAuthStateChanged,
            createUserWithEmailAndPassword,
            RecaptchaVerifier,
            signInWithPhoneNumber,
            PhoneAuthProvider,
            linkWithCredential,
            setPersistence,
            browserLocalPersistence
        } from 'https://www.gstatic.com/firebasejs/10.0.0/firebase-auth.js';
        import {
            getDatabase,
            ref,
            get,
            set,
            update,
            query,
            orderByKey
        } from 'https://www.gstatic.com/firebasejs/10.0.0/firebase-database.js';

        // Firebase configuration - Ensure these are correctly populated for your deployment
        const firebaseConfig = {
            apiKey: "AIzaSyBU3K7gRzqiqQt3o9thoEpd06ReLGVmm_w", // Replace with your actual API Key
            authDomain: "diya-hero.firebaseapp.com",
            databaseURL: "https://diya-hero-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "diya-hero",
            storageBucket: "diya-hero.firebasestorage.app",
            messagingSenderId: "455829653263",
            appId: "1:455829653263:web:5a31c65bdab2b9cee0607a",
            measurementId: "G-DZYHPLQD3F"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getDatabase(app);

        // --- Global State Variables ---
        let currentUserData = null;
        let confirmationResult = null;
        let phoneNumberToVerify = '';
        const OTP_COOLDOWN_SECONDS = 120;
        let otpCountdownInterval = null;
        let recaptchaVerifierInstance = null;
        let recaptchaWidgetId = null;
        let currentDeviceId = null;
        let todayAttendanceData = null;
        let isTodayHoliday = false;
        let hasLoadedAttendanceOnce = false; // To prevent resetting form on subsequent updateFormState calls

        let isProcessingAuthState = false;
        let lastProcessedUID = null;

        // No longer need branchesData as branch/subdivision are removed from signup
        // let branchesData = {}; // Stores fetched branch data

        // --- DOM Elements (initialized in getDomElements) ---
        const dom = {};

        function getDomElements() {
            dom.authScreens = document.getElementById('auth-screens');
            dom.appScreen = document.getElementById('app-screen');

            // Login Form Elements
            dom.loginForm = document.getElementById('login-form');
            dom.loginEmailInput = document.getElementById('login-email');
            dom.loginPasswordInput = document.getElementById('login-password');
            dom.loginBtn = document.getElementById('login-btn');
            dom.showSignupBtn = document.getElementById('show-signup-btn');
            dom.loginMessage = document.getElementById('login-message');

            // Phone Verification Form Elements
            dom.phoneVerifyForm = document.getElementById('phone-verify-form');
            dom.last4DigitsInput = document.getElementById('last-4-digits');
            dom.verifyPhoneBtn = document.getElementById('verify-phone-btn');
            dom.backToLoginBtn = document.getElementById('back-to-login-btn');
            dom.phoneVerifyMessage = document.getElementById('phone-verify-message');

            // OTP Verification Form Elements
            dom.otpForm = document.getElementById('otp-form');
            dom.otpInput = document.getElementById('otp-input');
            dom.verifyOtpBtn = document.getElementById('verify-otp-btn');
            dom.resendOtpBtn = document.getElementById('resend-otp-btn');
            dom.countdownTimer = document.getElementById('countdown-timer');
            dom.recaptchaContainer = document.getElementById('recaptcha-container');
            dom.otpMessage = document.getElementById('otp-message');

            // Signup Form Elements
            dom.signupForm = document.getElementById('signup-form');
            dom.signupNameInput = document.getElementById('signup-name');
            dom.signupEmailInput = document.getElementById('signup-email');
            dom.signupPasswordInput = document.getElementById('signup-password');
            dom.signupEmployeeIdInput = document.getElementById('signup-employee-id');
            dom.signupPhoneInput = document.getElementById('signup-phone');
            // Removed dom.branchSelect and dom.subdivisionSelect
            dom.signupBtn = document.getElementById('signup-btn');
            dom.showLoginBtn = document.getElementById('show-login-btn');
            dom.signupMessage = document.getElementById('signup-message');

            // App Screen Elements
            dom.logoutBtn = document.getElementById('logout-btn');
            dom.userDisplayName = document.getElementById('user-display-name');
            dom.locationStatus = document.getElementById('location-status');
            dom.locationMessage = document.getElementById('location-message');
            dom.attendanceSection = document.getElementById('attendance-section');
            dom.morningCheck = document.getElementById('morning-check');
            dom.anEnters = document.getElementById('an-enters');
            dom.anLeaves = document.getElementById('an-leaves');
            dom.anNone = document.getElementById('an-none');
            dom.exitCheckbox = document.getElementById('exit-checkbox');
            dom.exitCheckboxGroup = document.getElementById('exit-checkbox-group');
            dom.refreshLocationBtn = document.getElementById('refresh-location-btn');
            dom.submitAttendanceBtn = document.getElementById('submit-attendance-btn');
            dom.attendanceMessage = document.getElementById('attendance-message');

            // Modal Elements
            dom.messageModalOverlay = document.getElementById('message-modal-overlay');
            dom.modalTitle = dom.messageModalOverlay ? dom.messageModalOverlay.querySelector('#modal-title') : null;
            dom.modalMessage = dom.messageModalOverlay ? dom.messageModalOverlay.querySelector('#modal-message') : null;
            dom.modalCloseBtn = dom.messageModalOverlay ? dom.messageModalOverlay.querySelector('.modal-close-btn') : null;
            dom.modalOkBtn = dom.messageModalOverlay ? dom.messageModalOverlay.querySelector('.modal-footer .btn') : null;
        }

        // --- Utility Functions ---

        /**
         * Displays a message in a designated DOM element.
         * @param {HTMLElement} element - The DOM element to display the message in.
         * @param {string} message - The message text.
         * @param {'error'|'success'|'info'} type - The type of message for styling.
         */
        function showMessage(element, message, type) {
            if (!element) return;
            element.textContent = message;
            element.classList.remove('hidden', 'error', 'success', 'info');
            element.classList.add(type);
        }

        /**
         * Hides a message from a designated DOM element.
         * @param {HTMLElement} element - The DOM element to hide the message from.
         */
        function hideMessage(element) {
            if (!element) return;
            element.classList.add('hidden');
            element.textContent = '';
        }
        function capitalize(str) {
            return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
        }


        /**
         * Displays a custom modal with a title, message, and optional OK callback.
         * @param {string} title - The title of the modal.
         * @param {string} message - The message content of the modal.
         * @param {function} [onOkCallback=null] - Callback function to execute when OK is clicked.
         */
        function showModal(title, message, onOkCallback = null) {
            if (!dom.messageModalOverlay || !dom.modalTitle || !dom.modalMessage || !dom.modalCloseBtn || !dom.modalOkBtn) {
                return; // Cannot show modal if elements are missing
            }
            dom.modalTitle.textContent = title;
            dom.modalMessage.textContent = message;
            dom.messageModalOverlay.classList.add('show');

            const closeModal = () => {
                dom.messageModalOverlay.classList.remove('show');
                dom.modalCloseBtn.removeEventListener('click', closeModal);
                dom.modalOkBtn.removeEventListener('click', closeModalAndExecute);
            };

            const closeModalAndExecute = () => {
                closeModal();
                if (onOkCallback) {
                    onOkCallback();
                }
            };

            dom.modalCloseBtn.addEventListener('click', closeModal);
            dom.modalOkBtn.addEventListener('click', closeModalAndExecute);
        }

        /**
         * Toggles the visibility of authentication forms.
         * @param {'login'|'phone-verify'|'otp'|'signup'} view - The view to show.
         */
        function toggleAuthView(view) {
            dom.loginForm.classList.add('hidden');
            dom.phoneVerifyForm.classList.add('hidden');
            dom.otpForm.classList.add('hidden');
            dom.signupForm.classList.add('hidden');

            hideAllMessages();

            if (view === 'login') {
                dom.loginForm.classList.remove('hidden');
            } else if (view === 'phone-verify') {
                dom.phoneVerifyForm.classList.remove('hidden');
            } else if (view === 'otp') {
                dom.otpForm.classList.remove('hidden');
                if (dom.recaptchaContainer) {
                    dom.recaptchaContainer.style.display = 'block';
                }
                renderRecaptcha();
            } else if (view === 'signup') {
                dom.signupForm.classList.remove('hidden');
                // Removed populateBranchesDropdown() call as branch/subdivision are removed
            }
        }

        /** Hides all message boxes. */
        function hideAllMessages() {
            hideMessage(dom.loginMessage);
            hideMessage(dom.phoneVerifyMessage);
            hideMessage(dom.otpMessage);
            hideMessage(dom.signupMessage);
            hideMessage(dom.attendanceMessage);
        }
        function loadSignupBranches() {
            const branchSelect = document.getElementById("signup-branch");
            branchSelect.innerHTML = '<option value="">Select Branch</option>'; // Reset

            const directoryRef = ref(db, 'branchDirectory');
            get(directoryRef).then((snapshot) => {
                if (snapshot.exists()) {
                    const branches = snapshot.val();
                    Object.keys(branches).forEach((branch) => {
                        const option = document.createElement("option");
                        option.value = branch;
                        option.textContent = branches[branch].displayName || branch;
                        branchSelect.appendChild(option);
                    });
                } else {
                    console.warn("No branches found in branchDirectory");
                }
            }).catch((error) => {
                console.error("Error loading branches:", error);
            });
        }


        document.getElementById("signup-branch").addEventListener("change", async (e) => {
            const selectedBranch = e.target.value;
            const subdivisionSelect = document.getElementById("signup-subdivision");
            subdivisionSelect.innerHTML = `<option value="">Select Sub-division</option>`;

            if (!selectedBranch) return;

            try {
                const snapshot = await get(ref(db, `branchDirectory/${selectedBranch}/subdivisions`));
                if (snapshot.exists()) {
                    const subdivisions = snapshot.val();
                    Object.keys(subdivisions).forEach((sub) => {
                        const opt = document.createElement("option");
                        opt.value = sub;
                        opt.textContent = capitalize(sub);
                        subdivisionSelect.appendChild(opt);
                    });
                } else {
                    console.warn("No subdivisions found in branchDirectory for", selectedBranch);
                }
            } catch (error) {
                console.error("Error loading subdivisions:", error);
            }
        });

        /** Starts the OTP resend countdown timer. */
        function startOtpCountdown() {
            let seconds = OTP_COOLDOWN_SECONDS;
            dom.resendOtpBtn.disabled = true;
            dom.countdownTimer.textContent = `(${seconds}s)`;

            otpCountdownInterval = setInterval(() => {
                seconds--;
                dom.countdownTimer.textContent = `(${seconds}s)`;
                if (seconds <= 0) {
                    clearInterval(otpCountdownInterval);
                    dom.resendOtpBtn.disabled = false;
                    dom.countdownTimer.textContent = '';
                }
            }, 1000);
        }

        /** Renders the reCAPTCHA widget. */
        function renderRecaptcha() {
            if (recaptchaVerifierInstance && recaptchaWidgetId !== null) {
                grecaptcha.reset(recaptchaWidgetId);
                return;
            }

            if (dom.recaptchaContainer) {
                dom.recaptchaContainer.innerHTML = ''; // Clear previous reCAPTCHA if any
                dom.recaptchaContainer.style.display = 'block';
            } else {
                return;
            }

            recaptchaVerifierInstance = new RecaptchaVerifier(
                auth,
                dom.recaptchaContainer, {
                'size': 'invisible',
                'callback': (response) => {
                    // reCAPTCHA solved, proceed with phone verification
                },
                'expired-callback': () => {
                    showModal('reCAPTCHA Expired', 'Please verify reCAPTCHA again.');
                    if (recaptchaWidgetId !== null) {
                        grecaptcha.reset(recaptchaWidgetId);
                    }
                }
            }
            );

            recaptchaVerifierInstance.render().then(function (widgetId) {
                recaptchaWidgetId = widgetId;
            }).catch(() => {
                showModal('reCAPTCHA Error', 'Failed to load reCAPTCHA. Please refresh the page.');
            });
        }

        /** Generates or retrieves a unique device ID. */
        async function generateDeviceId() {
            // Attempt to fetch native device ID if available (e.g., from a WebView bridge)
            const nativeId = await fetchNativeDeviceId();
            if (nativeId) {
                currentDeviceId = nativeId;
                return;
            }

            // Fallback to localStorage if no native ID
            let id = localStorage.getItem('deviceId');
            if (!id) {
                id = 'device_' + Date.now() + Math.random().toString(36).substring(2, 15);
                localStorage.setItem('deviceId', id);
            }
            currentDeviceId = id;
        }

        /**
         * Checks if the current device is bound to the user's account, or binds it if it's the first login.
         * @param {string} userUid - The Firebase User UID.
         * @returns {Promise<boolean>} True if device is bound or successfully bound, false otherwise.
         */
        async function checkDeviceBinding(userUid) {
            if (!currentDeviceId) {
                await generateDeviceId();
            }

            const deviceRef = ref(db, `users/${userUid}/boundDevice`);
            const snapshot = await get(deviceRef);

            if (snapshot.exists()) {
                const savedDeviceId = snapshot.val();
                if (savedDeviceId !== currentDeviceId) {
                    showModal("Access Denied", "This account is already registered to another device.", async () => {
                        await signOut(auth);
                    });
                    return false;
                }
            } else {
                // Bind device for first time login
                await set(deviceRef, currentDeviceId);
            }
            return true;
        }

        /**
         * Calculates the distance between two geographical points using the Haversine formula.
         * @param {number} lat1 - Latitude of point 1.
         * @param {number} lon1 - Longitude of point 1.
         * @param {number} lat2 - Latitude of point 2.
         * @param {number} lon2 - Longitude of point 2.
         * @returns {number} Distance in meters.
         */
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth's radius in meters
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            const d = R * c;
            return d;
        }

        /**
         * Normalizes the afternoon status value.
         * @param {string|null|undefined} status - The afternoon status from DB.
         * @returns {string} Normalized status ('Enters', 'Leaves', or 'None').
         */
        function normalizeAfternoon(status) {
            return status === null || status === undefined ? "None" : status;
        }

        /**
         * Sets the checked state of radio buttons based on a value.
         * @param {HTMLInputElement[]} radios - An array of radio button elements.
         * @param {string} value - The value to check.
         */
        function setCheckedByValue(radios, value) {
            radios.forEach(radio => {
                radio.checked = radio.value === value;
            });
        }

        /**
         * Enables a list of radio buttons.
         * @param {HTMLInputElement[]} radios - An array of radio button elements.
         */
        function enableRadios(radios) {
            radios.forEach(radio => radio.disabled = false);
        }

        /**
         * Disables a list of radio buttons.
         * @param {HTMLInputElement[]} radios - An array of radio button elements.
         */
        function disableRadios(radios) {
            radios.forEach(radio => radio.disabled = true);
        }

        /** Disables all attendance controls. */
        function disableAllControls() {
            if (dom.morningCheck) dom.morningCheck.disabled = true;
            disableRadios([dom.anEnters, dom.anLeaves, dom.anNone]);
            if (dom.exitCheckbox) dom.exitCheckbox.disabled = true;
            if (dom.submitAttendanceBtn) dom.submitAttendanceBtn.disabled = true;
            if (dom.attendanceMessage) hideMessage(dom.attendanceMessage);
        }

        /**
         * Returns the current date string, hour, and minute.
         * @returns {{dateString: string, hour: number, minute: number}}
         */
        function getCurrentTimeParts() {
            const now = new Date();
            const dateString = now.toISOString().slice(0, 10); // YYYY-MM-DD
            const hour = now.getHours();
            const minute = now.getMinutes();
            return { dateString, hour, minute };
        }

        /**
         * Fetches today's attendance data for the current user.
         * @param {boolean} isInitialLoad - True if this is the first load of attendance data.
         */
        async function fetchTodayAttendance(isInitialLoad = false) {
            // Updated path as branch and subdivision are no longer part of user signup
            if (!currentUserData || !currentUserData.employeeId
            ) { // Removed branch and subdivision check
                todayAttendanceData = null;
                return;
            }
            const { dateString } = getCurrentTimeParts();
            // Attendance path now only uses user ID
            const branch = currentUserData.branch;
            const subdivision = currentUserData.subdivision;
            const empId = currentUserData.employeeId
                ;

            if (!branch || !subdivision || !empId) {
                console.warn("⚠️ Missing branch/subdivision in user profile");
                todayAttendanceData = null;
                return;
            }
            // Exit Attendance Submission Path (Fix)
            const dt = luxon.DateTime.fromISO(dateString, { zone: "Asia/Kolkata" });
            const year = String(dt.year);
            const month = String(dt.month).padStart(2, "0");
            const day = String(dt.day).padStart(2, "0");

            const attendancePath = `attendance/${year}/${month}/${day}/${branch}/${subdivision}/${empId}`;
            const attendanceRef = ref(db, attendancePath);

            try {
                const snapshot = await get(attendanceRef);
                todayAttendanceData = snapshot.exists() ? snapshot.val() : null;

                if (isInitialLoad && !hasLoadedAttendanceOnce) {
                    // Populate form fields from DB only on initial load
                    if (dom.morningCheck) {
                        dom.morningCheck.checked = todayAttendanceData?.morning === true;
                    }
                    const dbAfternoonStatus = normalizeAfternoon(todayAttendanceData?.afternoon);
                    setCheckedByValue([dom.anEnters, dom.anLeaves, dom.anNone], dbAfternoonStatus);
                    if (dom.exitCheckbox) {
                        dom.exitCheckbox.checked = todayAttendanceData?.anExit === true;
                    }
                    hasLoadedAttendanceOnce = true;
                }
            } catch (error) {
                console.error("Error fetching today's attendance data:", error);
                todayAttendanceData = null;
            }
        }

        /** Fetches today's holiday status from Firebase. */
        async function fetchHolidayStatus() {
            const { dateString } = getCurrentTimeParts();
            const holidayRef = ref(db, `holidays/${dateString}`);
            try {
                const snapshot = await get(holidayRef);
                isTodayHoliday = snapshot.exists() && snapshot.val() === true;
            } catch (error) {
                console.error("Error fetching holiday status:", error);
                isTodayHoliday = false;
            }
        }

        /** Updates the state of attendance form controls based on time, location, and DB data. */
        async function updateFormState() {
            hideMessage(dom.attendanceMessage);
            disableAllControls();

            const { hour, minute } = getCurrentTimeParts();

            const isLocationVerified = dom.locationStatus && dom.locationStatus.classList.contains('verified');

            if (!isLocationVerified) {
                showMessage(dom.attendanceMessage, "Location not verified. Attendance controls are disabled.", 'error');
                return;
            }

            await fetchHolidayStatus();
            if (isTodayHoliday) {
                showMessage(dom.attendanceMessage, "Today is a holiday. Attendance is not required.", 'info');
                return;
            }

            await fetchTodayAttendance(false); // Fetch latest data, but don't reset form if already interacted with

            const morningLocked = todayAttendanceData?.morningLocked === true;
            const anLocked = todayAttendanceData?.anLocked === true;
            const anExitMarked = todayAttendanceData?.anExit === true;

            // Current state from UI (user interaction takes precedence if not locked)
            const morningChecked = dom.morningCheck.checked;
            const afternoonStatus = document.querySelector('input[name="afternoon-status"]:checked')?.value || 'None';
            const exitChecked = dom.exitCheckbox.checked;

            // Exit Checkbox (UI visibility and initial state)
            if (anExitMarked) {
                dom.exitCheckbox.checked = true;
                dom.exitCheckbox.disabled = true;
                showMessage(dom.attendanceMessage, "Your attendance for today is finalized.", 'success');
                dom.submitAttendanceBtn.disabled = true;
                dom.exitCheckboxGroup.classList.remove('hidden'); // Ensure it's visible if already marked
                return; // Exit early if attendance is finalized
            } else {
                dom.exitCheckbox.disabled = true; // Default to disabled
                const isExitWindow = (hour >= 15 && hour <= 18) && (hour < 18 || (hour === 18 && minute <= 45));
                if (isExitWindow) {
                    dom.exitCheckboxGroup.classList.remove('hidden');
                } else {
                    dom.exitCheckboxGroup.classList.add('hidden');
                }
            }

            // Morning Attendance
            if (morningLocked) {
                dom.morningCheck.checked = true; // Reflect DB state
                dom.morningCheck.disabled = true;
            } else if (hour >= 8 && hour < 12) { // 08:00 to 11:59 AM
                dom.morningCheck.disabled = false;
            } else {
                dom.morningCheck.disabled = true;
                // If the window passed and the checkbox wasn't checked, it's considered null for the day
                // No need to explicitly set to null here, just disable
            }

            // Afternoon Attendance
            // Afternoon Attendance
            if (anLocked) {
                setCheckedByValue([dom.anEnters, dom.anLeaves, dom.anNone], normalizeAfternoon(todayAttendanceData?.afternoon));
                disableRadios([dom.anEnters, dom.anLeaves, dom.anNone]);
            } else if (hour >= 12 && hour < 15) { // 12:00 PM to 14:59 PM
                enableRadios([dom.anNone]); // Always allow None

                const morningStatus = dom.morningCheck.checked;


                if (morningStatus) {
                    dom.anEnters.disabled = true;
                    dom.anLeaves.disabled = false;
                } else {
                    dom.anEnters.disabled = false;
                    dom.anLeaves.disabled = true;
                }
            } else {
                disableRadios([dom.anEnters, dom.anLeaves, dom.anNone]);
            }


            // Exit Attendance (re-evaluation after morning/afternoon state)
            if (!anExitMarked && (hour >= 15 && hour <= 18) && (hour < 18 || (hour === 18 && minute <= 45))) { // 15:00 to 18:45
                const currentMorningStatus = dom.morningCheck.checked;
                const currentAfternoonStatus = document.querySelector('input[name="afternoon-status"]:checked')?.value || 'None';

                const canEnableExit =
                    (currentMorningStatus && currentAfternoonStatus === 'None') || // Morning checked, Afternoon not marked
                    (!currentMorningStatus && currentAfternoonStatus === 'Enters'); // Morning not checked, Afternoon marked as Enters

                if (canEnableExit) {
                    dom.exitCheckbox.disabled = false;
                } else {
                    dom.exitCheckbox.disabled = true;
                }
            }

            // Submit Button Enable/Disable Logic
            let enableSubmit = false;
            if (isLocationVerified && !anExitMarked) {
                const morningChanged = dom.morningCheck.checked !== (todayAttendanceData?.morning === true);
                const afternoonChanged = afternoonStatus !== normalizeAfternoon(todayAttendanceData?.afternoon);
                const exitChanged = dom.exitCheckbox.checked !== (todayAttendanceData?.anExit === true);

                // Enable submit if any relevant, unlocked field has changed its value
                if (
                    (morningChanged && !morningLocked) ||
                    (afternoonChanged && !anLocked) ||
                    (exitChanged && dom.exitCheckbox.checked && !dom.exitCheckbox.disabled) // Only enable if exit is checked AND it's not disabled (meaning it's markable)
                ) {
                    enableSubmit = true;
                }
            }
            dom.submitAttendanceBtn.disabled = !enableSubmit;
        }

        /** Handles the submission of attendance data. */
        async function submitAttendance() {
            hideMessage(dom.attendanceMessage);
            dom.submitAttendanceBtn.disabled = true;

            const { dateString, hour, minute } = getCurrentTimeParts();
            const timestamp = new Date().toISOString(); // Use current real-time for timestamp

            const currentMorningChecked = dom.morningCheck.checked;
            const currentAfternoonStatus = document.querySelector('input[name="afternoon-status"]:checked')?.value || 'None';
            const currentExitChecked = dom.exitCheckbox.checked;

            await fetchTodayAttendance(); // Ensure we have the latest DB state
            const dbMorning = todayAttendanceData?.morning === true;
            const dbAfternoon = normalizeAfternoon(todayAttendanceData?.afternoon);
            const dbAnExit = todayAttendanceData?.anExit === true;
            const dbMorningLocked = todayAttendanceData?.morningLocked === true;
            const dbAnLocked = todayAttendanceData?.anLocked === true;

            let payload = {};
            let submissionError = false;

            // Morning Attendance Validation and Payload
            if (currentMorningChecked !== dbMorning && !dbMorningLocked) {
                if (hour >= 8 && hour < 12) { // 08:00 to 11:59 AM
                    payload.morning = currentMorningChecked;
                    payload.morningTime = timestamp;
                    payload.morningLocked = currentMorningChecked; // Lock if checked
                } else {
                    showMessage(dom.attendanceMessage, "Morning attendance can only be marked between 8 AM and 11:59 AM.", 'error');
                    submissionError = true;
                }
            }

            // Afternoon Attendance Validation and Payload
            if (!submissionError && currentAfternoonStatus !== dbAfternoon && !dbAnLocked) {
                if (hour >= 12 && hour < 15) { // 12:00 PM to 14:59 PM (strict cutoff 15:00)
                    if (currentMorningChecked && currentAfternoonStatus === "Enters") {
                        showMessage(dom.attendanceMessage, "Cannot mark 'Enters' if morning attendance is checked.", 'error');
                        submissionError = true;
                    } else if (!currentMorningChecked && currentAfternoonStatus === "Leaves") {
                        showMessage(dom.attendanceMessage, "Cannot mark 'Leaves' if morning attendance is not checked.", 'error');
                        submissionError = true;
                    } else {
                        payload.afternoon = currentAfternoonStatus;
                        payload.anTime = timestamp;
                        if (currentAfternoonStatus !== 'None') {
                            payload.anLocked = true; // Lock if Enters/Leaves is selected
                        }
                    }
                } else {
                    showMessage(dom.attendanceMessage, "Afternoon attendance can only be marked between 12 PM and 2:59 PM.", 'error');
                    submissionError = true;
                }
            }

            // Exit Attendance Validation and Payload
            if (!submissionError && currentExitChecked !== dbAnExit && !dbAnExit) { // Only allow if not already marked
                if ((hour >= 15 && hour <= 18) && (hour < 18 || (hour === 18 && minute <= 45))) { // 15:00 to 18:45
                    const canMarkExit =
                        (currentMorningChecked && currentAfternoonStatus === 'None') ||
                        (!currentMorningChecked && currentAfternoonStatus === 'Enters');

                    if (!canMarkExit) {
                        showMessage(dom.attendanceMessage, "Cannot mark exit based on current Morning/Afternoon status.", 'error');
                        submissionError = true;
                    } else {
                        payload.anExit = currentExitChecked;
                        payload.anExitTime = timestamp;
                        payload.anLocked = true; // Lock afternoon if exit is marked
                        payload.morningLocked = true; // Lock morning if exit is marked
                    }
                } else {
                    showMessage(dom.attendanceMessage, "Exit can only be marked between 3 PM and 6:45 PM.", 'error');
                    submissionError = true;
                }
            }

            if (submissionError) {
                await updateFormState(); // Re-evaluate form state after an error
                return;
            }

            if (Object.keys(payload).length === 0) {
                showMessage(dom.attendanceMessage, "No changes to submit.", 'info');
                await updateFormState();
                return;
            }

            payload.locationVerified = dom.locationStatus.classList.contains('verified');
            payload.timestamp = timestamp; // Overall submission timestamp

            // ✅ Nested attendance path using branch/subdivision
            const branch = currentUserData.branch;
            const subdivision = currentUserData.subdivision;
            const empId = currentUserData.employeeId
                ;

            if (!branch || !subdivision || !empId) {
                showMessage(dom.attendanceMessage, "Your profile is missing branch/subdivision. Contact Admin.", 'error');
                return;
            }
 const dt = luxon.DateTime.fromISO(dateString, { zone: "Asia/Kolkata" });
            const year = String(dt.year);
            const month = String(dt.month).padStart(2, "0");
            const day = String(dt.day).padStart(2, "0");

            const attendancePath = `attendance/${year}/${month}/${day}/${branch}/${subdivision}/${empId}`;
            const attendanceRef = ref(db, attendancePath);


            try {
                await update(attendanceRef, payload);
                showMessage(dom.attendanceMessage, 'Attendance saved successfully!', 'success');
                showModal('Success', 'Attendance saved!');
                await updateFormState(); // Re-evaluate form state after successful submission
            } catch (error) {
                showMessage(dom.attendanceMessage, `Error submitting attendance: ${error.message}`, 'error');
                showModal('Submission Failed', `Failed to record attendance: ${error.message}`);
            } finally {
                dom.submitAttendanceBtn.disabled = false;
            }
        }

        /** Handles user login. */
        async function handleLogin() {
            const email = dom.loginEmailInput?.value?.trim();
            const password = dom.loginPasswordInput?.value?.trim();

            if (!email || !password) {
                showMessage(dom.loginMessage, 'Please enter both email and password.', 'error');
                return;
            }

            hideMessage(dom.loginMessage);
            dom.loginBtn.disabled = true;
            try {
                await setPersistence(auth, browserLocalPersistence);
                await signInWithEmailAndPassword(auth, email, password);
            } catch (error) {
                let errorMessage = "Login failed. Please check your credentials.";
                if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
                    errorMessage = "Invalid email or password.";
                } else if (error.code === 'auth/too-many-requests') {
                    errorMessage = "Too many login attempts. Please try again later.";
                }
                showMessage(dom.loginMessage, errorMessage, 'error');
            } finally {
                dom.loginBtn.disabled = false;
            }
        }

        // Removed populateBranchesDropdown function
        // Removed populateSubdivisionsDropdown function

        /** Handles user signup. */
        async function handleSignup() {
            const name = dom.signupNameInput?.value?.trim();
            const email = dom.signupEmailInput?.value?.trim();
            const password = dom.signupPasswordInput?.value?.trim();
            const employeeId = dom.signupEmployeeIdInput?.value?.trim();
            const phone = dom.signupPhoneInput?.value?.trim();
            const branch = document.getElementById("signup-branch")?.value?.trim();
            const subdivision = document.getElementById("signup-subdivision")?.value?.trim();

            // Simple validation
            if (!name || !email || !password || !employeeId || !phone || !branch || !subdivision) {
                dom.signupMessage.textContent = "Please fill all fields.";
                dom.signupMessage.className = "message-box error";
                dom.signupMessage.classList.remove("hidden");
                return;
            }

            try {
                // Check for duplicate employee ID or email
                const existingSnap = await get(ref(db, `signupRequests/${employeeId}`));
                if (existingSnap.exists()) {
                    dom.signupMessage.textContent = "A signup request with this Employee ID already exists.";
                    dom.signupMessage.className = "message-box error";
                    dom.signupMessage.classList.remove("hidden");
                    return;
                }

                // Submit to signupRequests
                await set(ref(db, `signupRequests/${employeeId}`), {
                    name: name.trim(),
                    email: email.trim(),
                    password: password.trim(),
                    phone: phone.trim(),               // ✅ MUST be string
                    employeeId: employeeId.trim(),     // ✅ MUST be string
                    branch: branch.trim(),
                    subdivision: subdivision.trim(),
                    timestamp: Date.now(),             // Optional (number is OK)
                    submittedAt: new Date().toISOString() // ✅ MUST be string
                });


                dom.signupMessage.textContent = "Signup request submitted successfully. Please wait for admin approval.";
                dom.signupMessage.className = "message-box success";
                dom.signupMessage.classList.remove("hidden");
                dom.signupNameInput.value = '';
                dom.signupEmailInput.value = '';
                dom.signupPasswordInput.value = '';
                dom.signupEmployeeIdInput.value = '';
                dom.signupPhoneInput.value = '';

                const branchInput = document.getElementById('signup-branch');
                const subdivisionInput = document.getElementById('signup-subdivision');
                if (branchInput) branchInput.value = '';
                if (subdivisionInput) subdivisionInput.value = '';

            } catch (error) {
                console.error("Signup request failed:", error);
                dom.signupMessage.textContent = "Error submitting signup request. Try again later.";
                dom.signupMessage.className = "message-box error";
                dom.signupMessage.classList.remove("hidden");
            }
        }

        /** Handles phone number verification. */
        async function handlePhoneVerify() {
            const last4Digits = dom.last4DigitsInput?.value?.trim();

            if (last4Digits.length !== 4) {
                showMessage(dom.phoneVerifyMessage, 'Please enter the last 4 digits of your phone number.', 'error');
                return;
            }

            hideMessage(dom.phoneVerifyMessage);
            dom.verifyPhoneBtn.disabled = true;
            try {
                const user = auth.currentUser;
                if (!user) {
                    throw new Error("No user currently signed in. Please log in first.");
                }
                if (!currentUserData || !currentUserData.phone) {
                    throw new Error("User data or phone number not available for the current user.");
                }

                const registeredLast4 = currentUserData.phone.slice(-4);
                if (last4Digits !== registeredLast4) {
                    showMessage(dom.phoneVerifyMessage, 'Last 4 digits do not match your registered number.', 'error');
                    dom.verifyPhoneBtn.disabled = false;
                    return;
                }

                if (!recaptchaVerifierInstance) {
                    // Ensure reCAPTCHA is rendered if not already
                    renderRecaptcha();
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Give a moment for reCAPTCHA to render
                }

                const phoneNumber = currentUserData.phone;
                confirmationResult = await signInWithPhoneNumber(auth, phoneNumber, recaptchaVerifierInstance);
                window.verificationId = confirmationResult.verificationId; // Store for OTP verification
                phoneNumberToVerify = phoneNumber; // Store for resend OTP

                showMessage(dom.phoneVerifyMessage, 'OTP sent to your phone!', 'success');
                toggleAuthView('otp');
                startOtpCountdown();

            } catch (error) {
                let errorMessage = "Failed to send OTP.";
                if (error.code === 'auth/invalid-phone-number') {
                    errorMessage = "The provided phone number is invalid.";
                } else if (error.code === 'auth/missing-phone-number') {
                    errorMessage = "No phone number found for your account. Contact Admin.";
                } else if (error.code === 'auth/quota-exceeded') {
                    errorMessage = "Too many OTP requests. Please try again later.";
                }
                showMessage(dom.phoneVerifyMessage, errorMessage, 'error');
            } finally {
                dom.verifyPhoneBtn.disabled = false;
            }
        }

        /** Handles OTP verification. */
        async function handleOtpVerify() {
            const otp = dom.otpInput?.value?.trim();

            if (otp.length !== 6) {
                showMessage(dom.otpMessage, 'Please enter the 6-digit OTP.', 'error');
                return;
            }
            if (!window.verificationId) {
                showMessage(dom.otpMessage, 'No OTP request initiated. Please go back to phone verification.', 'error');
                return;
            }

            hideMessage(dom.otpMessage);
            dom.verifyOtpBtn.disabled = true;
            try {
                const credential = PhoneAuthProvider.credential(window.verificationId, otp);
                const user = auth.currentUser;
                if (!user) {
                    showModal('Verification Error', 'No user signed in. Please log in again.', async () => {
                        await signOut(auth);
                        toggleAuthView('login');
                    });
                    return;
                }

                // Link phone number to user if not already linked
                if (!user.phoneNumber) {
                    await linkWithCredential(user, credential);
                    if (currentUserData && currentUserData.uid) {
                        await update(ref(db, 'users/' + currentUserData.uid), {
                            isVerified: true
                        });
                        currentUserData.isVerified = true; // Update local state
                    } else {
                        showModal('Verification Error', 'Could not identify user for verification update. Please try again.');
                        await signOut(auth);
                        return;
                    }
                } else {
                    // If phone number is already linked, just ensure isVerified is true in DB
                    if (currentUserData && currentUserData.uid && !currentUserData.isVerified) {
                        await update(ref(db, 'users/' + currentUserData.uid), {
                            isVerified: true
                        });
                        currentUserData.isVerified = true; // Update local state
                    }
                }

                showMessage(dom.otpMessage, 'Phone number verified successfully!', 'success');
                showModal('Verification Success', 'Your phone number has been verified. Welcome!');

                dom.authScreens.classList.add('hidden');
                dom.appScreen.classList.remove('hidden');
                dom.userDisplayName.textContent = currentUserData.name;
                await checkUserLocationAndAttendance(); // Proceed to main app logic

            } catch (error) {
                let errorMessage = "Failed to verify OTP.";
                if (error.code === 'auth/invalid-verification-code') {
                    errorMessage = "Invalid OTP. Please try again.";
                } else if (error.code === 'auth/code-expired') {
                    errorMessage = "OTP expired. Please resend.";
                } else if (error.code === 'auth/credential-already-in-use') {
                    if (currentUserData && currentUserData.phone === error.customData._phoneNumber) {
                        // This scenario means the phone is already linked and verified for this user
                        showMessage(dom.otpMessage, 'Phone number already verified for this account.', 'success');
                        showModal('Already Verified', 'Your phone number is already verified. Welcome!');
                        dom.authScreens.classList.add('hidden');
                        dom.appScreen.classList.remove('hidden');
                        await checkUserLocationAndAttendance();
                    } else {
                        errorMessage = "This phone number is already linked to another account. Please log in with that account or contact Admin.";
                        showModal('Linking Error', errorMessage, async () => {
                            await signOut(auth);
                            toggleAuthView('login');
                        });
                    }
                    return;
                } else if (error.code === 'auth/no-current-user') {
                    errorMessage = "No user signed in to link the phone number to. Please log in again.";
                    showModal('Login Required', errorMessage, async () => {
                        await signOut(auth);
                        toggleAuthView('login');
                    });
                    return;
                }
                showMessage(dom.otpMessage, errorMessage, 'error');
            } finally {
                dom.verifyOtpBtn.disabled = false;
            }
        }

        /** Handles resending OTP. */
        async function handleResendOtp() {
            if (!phoneNumberToVerify) {
                showModal('Error', 'No phone number to resend OTP to. Please go back to phone verification.', () => {
                    toggleAuthView('phone-verify');
                });
                return;
            }

            hideMessage(dom.otpMessage);
            dom.resendOtpBtn.disabled = true;
            try {
                // Reset reCAPTCHA before sending new OTP
                if (recaptchaWidgetId !== null) {
                    grecaptcha.reset(recaptchaWidgetId);
                }

                confirmationResult = await signInWithPhoneNumber(auth, phoneNumberToVerify, recaptchaVerifierInstance);
                window.verificationId = confirmationResult.verificationId;

                showMessage(dom.otpMessage, 'New OTP sent!', 'success');
                startOtpCountdown();
            } catch (error) {
                let errorMessage = "Failed to resend OTP.";
                if (error.code === 'auth/quota-exceeded') {
                    errorMessage = "Too many OTP requests. Please try again later.";
                } else if (error.code === 'auth/invalid-phone-number') {
                    errorMessage = "Invalid phone number for resend. Please go back to verification.";
                }
                showMessage(dom.otpMessage, errorMessage, 'error');
            } finally {
                dom.resendOtpBtn.disabled = false;
            }
        }

        /** Handles user logout. */
        async function handleLogout() {
            try {
                await signOut(auth);
                currentUserData = null;
                hasLoadedAttendanceOnce = false; // Reset for next login
                showModal('Logged Out', 'You have been successfully logged out.');
            } catch (error) {
                showModal('Logout Error', 'Failed to log out. Please try again.');
            }
        }

        /**
         * Checks user's current location against their registered branch and updates UI.
         * Also fetches initial attendance data and holiday status.
         */
        async function checkUserLocationAndAttendance() {
            dom.locationStatus.classList.remove('verified', 'error');
            dom.locationMessage.textContent = 'Checking location...';
            disableAllControls(); // Disable controls until location is verified

            // Removed branch and subdivision check for currentUserData
            if (!currentUserData || !currentUserData.employeeId
                || !currentUserData.phone || !currentUserData.isVerified) {
                showMessage(dom.attendanceMessage, "User data incomplete for location check. Please contact admin.", 'error');
                dom.locationStatus.classList.add('error');
                dom.locationMessage.textContent = 'User data incomplete.';
                showModal("User Data Error", "Your profile data is incomplete. Please contact Admin for assistance. You will be logged out.", async () => {
                    await signOut(auth);
                    toggleAuthView('login');
                });
                return;
            }

            // Moved initial fetch of attendance and holiday status to updateFormState
            // This ensures they are always fresh when form state is evaluated

            if (!("geolocation" in navigator)) {
                dom.locationStatus.classList.remove('verified');
                dom.locationStatus.classList.add('error');
                dom.locationMessage.textContent = "Geolocation is not supported by your browser.";
                showMessage(dom.attendanceMessage, "Geolocation not supported. Attendance controls are disabled. Please use a compatible browser.", 'error');
                return;
            }

            try {
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        enableHighAccuracy: true,
                        timeout: 30000, // 30 seconds
                        maximumAge: 0 // No cached position
                    });
                });
                const {
                    latitude,
                    longitude
                } = position.coords;

                // Fetch the default branch location for all users
                // Auto-select first available branch from user's profile
                const selectedBranchName = currentUserData?.branch || null;


                if (!selectedBranchName) {
                    dom.locationStatus.classList.remove('verified');
                    dom.locationStatus.classList.add('error');
                    dom.locationMessage.textContent = `No branch assigned to your account.`;
                    showMessage(dom.attendanceMessage, "No branch found in your profile. Attendance disabled. Contact Admin.", 'error');
                    return;
                }

                const branchRef = ref(db, `branches/${selectedBranchName}`);
                const branchSnapshot = await get(branchRef);

                if (branchSnapshot.exists()) {
                    const branchData = branchSnapshot.val();
                    const branchLatitude = branchData.latitude;
                    const branchLongitude = branchData.longitude;
                    const radius = Number(branchData.radius);

                    if (!radius || isNaN(radius) || radius < 1) {
                        dom.locationStatus.classList.remove('verified');
                        dom.locationStatus.classList.add('error');
                        dom.locationMessage.textContent = `Radius missing or invalid for ${selectedBranchName}.`;
                        showMessage(dom.attendanceMessage, "Invalid radius. Cannot verify location. Contact Admin.", 'error');
                        return;
                    }

                    const distance = calculateDistance(latitude, longitude, branchLatitude, branchLongitude);

                    if (distance <= radius) {
                        dom.locationStatus.classList.remove('error');
                        dom.locationStatus.classList.add('verified');
                        dom.locationMessage.textContent = `✅ Location Verified: Distance ${distance.toFixed(2)}m `;
                        await updateFormState();
                    } else {
                        dom.locationStatus.classList.remove('verified');
                        dom.locationStatus.classList.add('error');
                        dom.locationMessage.textContent = `❌ Location NOT Verified: Outside permitted area. Distance: ${distance.toFixed(2)}m (Max: ${radius}m).`;
                        showMessage(dom.attendanceMessage, "You are outside the permitted location. Attendance is disabled.", 'error');
                    }

                } else {
                    dom.locationStatus.classList.remove('verified');
                    dom.locationStatus.classList.add('error');
                    dom.locationMessage.textContent = `Branch location data not found for ${selectedBranchName}.`;
                    showMessage(dom.attendanceMessage, `Branch location data missing for ${selectedBranchName}. Contact Admin.`, 'error');
                }

            } catch (error) {
                dom.locationStatus.classList.remove('verified');
                dom.locationStatus.classList.add('error');

                let geoErrorMessage = "Failed to get location.";

                if (error.code === 1) {
                    geoErrorMessage = "Location access denied by user/browser.";
                } else if (error.code === 2) {
                    geoErrorMessage = "Location unavailable (bad signal, disabled GPS, or airplane mode).";
                } else if (error.code === 3) {
                    geoErrorMessage = "Location request timed out. Try again.";
                }

                console.error("📍 Location error debug:", error);
                dom.locationMessage.textContent = `Location Error: ${geoErrorMessage}`;
                showMessage(dom.attendanceMessage, `Location error: ${geoErrorMessage}. Attendance disabled.`, 'error');
            }

        }

        /** Attempts to fetch a native device ID (e.g., from Android/iOS WebView bridge). */
        async function fetchNativeDeviceId() {
            if (window.DeviceBridge && typeof DeviceBridge.getDeviceId === 'function') {
                try {
                    const nativeId = await DeviceBridge.getDeviceId();
                    if (nativeId) {
                        localStorage.setItem('deviceId', nativeId); // Store for consistency
                        return nativeId;
                    }
                } catch (e) {
                    // Handle cases where native method might not be implemented or throws
                }
            }
            return null;
        }
        function validateEmployeeProfile(profile) {
            const requiredFields = ['employeeId', 'branch', 'subdivision', 'phone', 'name'];
            const missing = requiredFields.find(field =>
                profile[field] === undefined || profile[field] === null || profile[field].toString().trim() === ''
            );
            return missing || null;
        }

        onAuthStateChanged(auth, async (user) => {
            if (isProcessingAuthState && user && lastProcessedUID === user.uid) {
                return;
            }

            isProcessingAuthState = true;
            try {
                if (user) {
                    lastProcessedUID = user.uid;
                    await generateDeviceId();

                    const userRef = ref(db, `users/${user.uid}`);
                    const snapshot = await get(userRef);

                    if (snapshot.exists()) {
                        currentUserData = snapshot.val();
                        console.log("✅ Logged in UID:", user?.uid);
                        console.log("📦 Loaded user profile:", JSON.stringify(currentUserData, null, 2));

                        if (currentUserData.role !== 'Employee') {
                            showModal('Access Denied', 'You do not have employee access to this application.', async () => {
                                await signOut(auth);
                                dom.authScreens.classList.remove('hidden');
                                dom.appScreen.classList.add('hidden');
                                toggleAuthView('login');
                            });
                            return;
                        }

                        if (!currentUserData.employeeId) {

                            showModal('Profile Incomplete', 'Your employee profile is incomplete. Please contact Admin.', async () => {
                                await signOut(auth);
                                dom.authScreens.classList.remove('hidden');
                                dom.appScreen.classList.add('hidden');
                                toggleAuthView('login');
                            });
                            return;
                        }

                        if (!currentUserData.phone) {
                            showModal('Phone Not Found', 'Your registered phone number is missing or invalid. Please contact Admin.', async () => {
                                await signOut(auth);
                                dom.authScreens.classList.remove('hidden');
                                dom.appScreen.classList.add('hidden');
                                toggleAuthView('login');
                            });
                            return;
                        }

                        // ✅ Attempt to auto-detect branch/subdivision once
                        if (!currentUserData.branch || !currentUserData.subdivision) {
                            await autoDetectBranchSubByEmpId(currentUserData.employeeId
                            );
                            const updatedSnapshot = await get(ref(db, `users/${user.uid}`));
                            currentUserData = updatedSnapshot.val();

                            // Still not found after auto-detect
                            if (!currentUserData.branch || !currentUserData.subdivision) {
                                showModal("Missing Branch/Subdivision", "Your profile is incomplete. Please contact Admin.");
                                await signOut(auth);
                                return;
                            }
                        }

                        if (currentUserData.isVerified) {
                            const isBound = await checkDeviceBinding(user.uid);
                            if (!isBound) return;

                            dom.authScreens.classList.add('hidden');
                            dom.appScreen.classList.remove('hidden');
                            dom.userDisplayName.textContent = currentUserData.name;
                            await checkUserLocationAndAttendance();
                        } else {
                            dom.authScreens.classList.remove('hidden');
                            dom.appScreen.classList.add('hidden');
                            toggleAuthView('phone-verify');
                            showModal('Verification Required', 'Please verify your phone number to continue.');
                            if (currentUserData.phone && currentUserData.phone.length >= 4) {
                                dom.last4DigitsInput.value = currentUserData.phone.slice(-4);
                            }
                        }

                    } else {
                        showModal('User Data Missing', 'Your user profile is incomplete. Please contact Admin.', async () => {
                            await signOut(auth);
                            dom.authScreens.classList.remove('hidden');
                            dom.appScreen.classList.add('hidden');
                            toggleAuthView('login');
                        });
                    }

                } else {
                    currentUserData = null;
                    lastProcessedUID = null;
                    hasLoadedAttendanceOnce = false;
                    dom.authScreens.classList.remove('hidden');
                    dom.appScreen.classList.add('hidden');
                    toggleAuthView('login');
                }
            } catch (error) {
                console.error("Auth state processing error:", error);
                await signOut(auth);
                dom.authScreens.classList.remove('hidden');
                dom.appScreen.classList.add('hidden');
                showModal('Error', 'An unexpected error occurred. Please try again.');
                toggleAuthView('login');
            } finally {
                isProcessingAuthState = false;
            }
        });

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {

            getDomElements(); // Initialize DOM elements once DOM is ready

            // Authentication Event Listeners
            if (dom.loginBtn) dom.loginBtn.addEventListener('click', handleLogin);
            if (dom.verifyPhoneBtn) dom.verifyPhoneBtn.addEventListener('click', handlePhoneVerify);
            if (dom.verifyOtpBtn) dom.verifyOtpBtn.addEventListener('click', handleOtpVerify);
            if (dom.resendOtpBtn) dom.resendOtpBtn.addEventListener('click', handleResendOtp);
            if (dom.signupBtn) dom.signupBtn.addEventListener('click', handleSignup);
            if (dom.logoutBtn) dom.logoutBtn.addEventListener('click', handleLogout);
            if (dom.refreshLocationBtn) dom.refreshLocationBtn.addEventListener('click', checkUserLocationAndAttendance);
            if (document.getElementById("signup-branch")) {
                loadSignupBranches();
            }

            // View Toggling Buttons
            if (dom.showSignupBtn) dom.showSignupBtn.addEventListener('click', () => toggleAuthView('signup'));
            if (dom.showLoginBtn) dom.showLoginBtn.addEventListener('click', () => toggleAuthView('login'));
            if (dom.backToLoginBtn) dom.backToLoginBtn.addEventListener('click', () => toggleAuthView('login'));

            // Removed Signup Form Dropdown Listeners
            // if (dom.branchSelect) {
            //     dom.branchSelect.addEventListener('change', () => {
            //         populateSubdivisionsDropdown(dom.branchSelect.value);
            //     });
            // }

            // Attendance Form Control Listeners (trigger updateFormState on change)
            if (dom.morningCheck) dom.morningCheck.addEventListener('change', updateFormState);
            if (dom.anEnters) dom.anEnters.addEventListener('change', updateFormState);
            if (dom.anLeaves) dom.anLeaves.addEventListener('change', updateFormState);
            if (dom.anNone) dom.anNone.addEventListener('change', updateFormState);
            if (dom.exitCheckbox) dom.exitCheckbox.addEventListener('change', updateFormState);
            if (dom.submitAttendanceBtn) dom.submitAttendanceBtn.addEventListener('click', submitAttendance);

        });
        const branchSelect = document.getElementById("signup-branch");
        if (branchSelect) {
            branchSelect.addEventListener("change", (e) => {
                const selectedBranch = e.target.value;
                if (selectedBranch) {
                    populateSubdivisionsDropdown(selectedBranch);
                }
            });
        }

        async function autoDetectBranchSubByEmpId(empId) {
            const branchesRef = ref(db, "branches");
            const branchesSnap = await get(branchesRef);

            if (!branchesSnap.exists()) {
                throw new Error("No branches found in database.");
            }

            const branchesData = branchesSnap.val();

            for (const branchName in branchesData) {
                const branch = branchesData[branchName];
                const subdivisions = branch.subdivisions;

                if (!subdivisions) continue;

                for (const subdivisionName in subdivisions) {
                    const employees = subdivisions[subdivisionName]?.employees;
                    if (employees && employees[empId]) {
                        // ✅ Match found
                        return {
                            branch: branchName,
                            subdivision: subdivisionName
                        };
                    }
                }
            }

            throw new Error(`Employee ID ${empId} not found in any branch/subdivision.`);
        }

    </script>



    <script>
        // This script runs outside the module, so it's global.
        // Replace alert with showModal
        fetch('https://ipapi.co/json/')
            .then(res => res.json())
            .then(data => {
                const ip = data.ip;
                const vpn = data.security?.vpn || false;
                const proxy = data.security?.proxy || false;
                const tor = data.security?.tor || false;
                const isp = data.org;
                const country = data.country_name;

                // Save IP info to Firebase (assuming DeviceBridge is available)
                if (window.DeviceBridge) {
                    DeviceBridge.logIPInfo(ip, vpn, proxy, tor, isp, country);
                }

                // Handle block logic
                if (vpn || proxy || tor) {
                    // Use showModal instead of alert
                    // Ensure dom.showModal is available, or define a global showModal if this script runs before DOM is ready
                    // For now, assuming showModal is accessible or this is a temporary block.
                    // A more robust solution would be to defer this check until the app is fully initialized.
                    if (typeof showModal === 'function') {
                        showModal("Access Denied", "⚠️ VPN/Proxy/Tor usage detected. Access Denied.", () => {
                            window.location.href = "https://czviewer.github.io/Blocked/";
                        });
                    } else {
                        // Fallback if showModal is not yet defined (e.g., script execution order)
                        // This fallback is technically not needed anymore as showModal is globally available.
                        // However, keeping it for extreme edge cases where the module script might load later.
                        alert("⚠️ VPN/Proxy/Tor usage detected. Access Denied."); // This line can be removed if showModal is guaranteed to be ready.
                        window.location.href = "https://czviewer.github.io/Blocked/";
                    }
                }
            })
            .catch(error => {
                console.error("Error fetching IP info:", error);
                // Optionally show a modal about network issues if IP check fails
            });
    </script>

    <!-- Google reCAPTCHA API script -->
    <!-- The onloadCallback is implicitly called by the reCAPTCHA script once it's loaded -->
    <script src="https://www.google.com/recaptcha/api.js?onload=onloadCallback&render=explicit" async defer></script>

</body>

</html>